<p align="center">
  <a href="./00-OVERVIEW.md">Overview</a> •
  <a href="./04-IMPLEMENTATION.md">Implementation</a> •
  <a href="./05-CHALLENGES.md">Challenges</a>
</p>


<hr />

<h1> Implementation Guide</h1>

<p>
This guide explains how the Network Traffic Analyzer works internally.  
It covers <strong>A)</strong> the current implementation you have today, and <strong>B)</strong> the expanded, modular architecture you are building toward.
</p>

<hr />

<h2> A) Current Implementation (Your Actual Codebase)</h2>

<p>
Your current analyzer is built around four core modules:
</p>

<pre><code>src/netanal/
├── capture.py      # Packet capture logic
├── parser.py       # Packet parsing and field extraction
├── detectors.py    # Detection logic (e.g., SYN flood)
├── stats.py        # Statistics aggregation
└── main.py         # Entry point (script-style)
</code></pre>

<h3>1. main.py — The Coordinator</h3>

<p>
Your <code>main.py</code> wires the system together. It:
</p>

<ul>
  <li>captures packets</li>
  <li>parses them</li>
  <li>updates statistics</li>
  <li>runs detectors</li>
  <li>prints alerts</li>
</ul>

<p>Current structure:</p>

<pre><code>def handle_packet(pkt):
    parsed = parse_packet(pkt)
    if not parsed:
        return

    update_stats(parsed)

    alert = detect_syn_flood(parsed)
    if alert:
        print("[ALERT]", alert)

capture_packets(handle_packet)
</code></pre>

<p>
This is a simple, functional pipeline. It processes packets as they arrive and performs detection in real time.
</p>

<hr />

<h3>2. capture.py — Packet Capture</h3>

<p>
Your capture module uses Scapy to sniff packets and forward them to <code>handle_packet()</code>.  
It is a single-threaded, callback-based design — simple and effective for low to moderate traffic.
</p>

<p>
In the future, this will evolve into a producer–consumer engine with a bounded queue.
</p>

<hr />

<h3>3. parser.py — Packet Parsing</h3>

<p>
This module extracts:
</p>

<ul>
  <li>source/destination IP</li>
  <li>ports</li>
  <li>protocol</li>
  <li>flags</li>
  <li>packet size</li>
</ul>

<p>
It returns a normalized Python dictionary or object that the rest of the system can use.
</p>

<hr />

<h3>4. detectors.py — Detection Logic</h3>

<p>
Your current detector implements a SYN flood heuristic:
</p>

<ul>
  <li>track SYN packets</li>
  <li>detect abnormal rates</li>
  <li>raise alerts</li>
</ul>

<p>
This is the foundation for future IDS-style detection modules.
</p>

<hr />

<h3>5. stats.py — Statistics Aggregation</h3>

<p>
This module maintains counters such as:
</p>

<ul>
  <li>total packets</li>
  <li>protocol counts</li>
  <li>source/destination activity</li>
</ul>

<p>
In the expanded architecture, this becomes a thread-safe <code>StatisticsCollector</code>.
</p>

<hr />

<h2> Summary of Current Implementation</h2>

<p>
Your current analyzer is a clean, minimal pipeline:
</p>

<pre><code>capture → parse → update stats → detect → alert
</code></pre>

<p>
This is the perfect foundation for the expanded architecture.
</p>

<hr />

<h1> B) Expanded Architecture (Professional, Modular System)</h1>

<p>
This section describes the <strong>full architecture</strong> your project is evolving toward — the one reflected in your README and documentation.
</p>

<p>
These modules do not all exist yet, but this guide explains how they fit together and how your current code will grow into them.
</p>

<pre><code>src/netanal/
├── main.py           # Typer CLI
├── capture.py        # Producer-consumer capture engine
├── analyzer.py       # Protocol identification
├── filters.py        # BPF filter builder
├── statistics.py     # Thread-safe stats collector
├── models.py         # PacketInfo, Protocol, Stats dataclasses
├── visualization.py  # Matplotlib charts
├── export.py         # JSON/CSV export
├── output.py         # Rich console formatting
├── constants.py      # Config values
└── exceptions.py     # Custom errors
</code></pre>

<hr />

<h2>1. Capture Engine (Future Version)</h2>

<p>
The expanded <code>CaptureEngine</code> uses:
</p>

<ul>
  <li>a producer thread (Scapy AsyncSniffer)</li>
  <li>a consumer thread (processing loop)</li>
  <li>a bounded queue to prevent memory blowup</li>
  <li>thread-safe counters</li>
</ul>

<p>
This design allows high-speed packet capture without dropping packets.
</p>

<hr />

<h2>2. analyzer.py — Protocol Identification</h2>

<p>
This module classifies packets into:
</p>

<ul>
  <li>TCP</li>
  <li>UDP</li>
  <li>ICMP</li>
  <li>DNS</li>
  <li>HTTP/HTTPS</li>
  <li>OTHER</li>
</ul>

<p>
It uses Scapy layers and port-based heuristics.
</p>

<hr />

<h2>3. filters.py — BPF Filter Builder</h2>

<p>
This module constructs safe, validated BPF expressions:
</p>

<pre><code>FilterBuilder().protocol(Protocol.HTTP).port(80).build()
</code></pre>

<p>
This offloads filtering to the kernel for massive performance gains.
</p>

<hr />

<h2>4. statistics.py — Thread-Safe Stats Collector</h2>

<p>
The expanded collector tracks:
</p>

<ul>
  <li>protocol distribution</li>
  <li>endpoint activity</li>
  <li>conversations</li>
  <li>bandwidth samples</li>
</ul>

<p>
All updates occur under a single lock to prevent race conditions.
</p>

<hr />

<h2>5. models.py — Data Structures</h2>

<p>
Defines:
</p>

<ul>
  <li><code>PacketInfo</code></li>
  <li><code>Protocol</code> enum</li>
  <li><code>CaptureStatistics</code></li>
</ul>

<p>
This gives your analyzer a clean, typed internal representation.
</p>

<hr />

<h2>6. visualization.py — Charts</h2>

<p>
Generates:
</p>

<ul>
  <li>protocol distribution pie charts</li>
  <li>bandwidth graphs</li>
  <li>top talker bar charts</li>
</ul>

<hr />

<h2>7. export.py — JSON/CSV Export</h2>

<p>
Allows saving capture results for offline analysis.
</p>

<hr />

<h2>8. output.py — Rich Console Formatting</h2>

<p>
Provides:
</p>

<ul>
  <li>tables</li>
  <li>summaries</li>
  <li>color-coded output</li>
</ul>

<hr />

<h2>9. constants.py — Configuration</h2>

<p>
Stores:
</p>

<ul>
  <li>queue size</li>
  <li>bandwidth interval</li>
  <li>color mappings</li>
</ul>

<hr />

<h2>10. exceptions.py — Custom Errors</h2>

<p>
Defines structured exceptions for:
</p>

<ul>
  <li>permissions</li>
  <li>invalid filters</li>
  <li>capture failures</li>
</ul>

<hr />

<h1> Final Notes</h1>

<p>
This Implementation Guide now covers:
</p>

<ul>
  <li><strong>A)</strong> Your current implementation (simple, functional pipeline)</li>
  <li><strong>B)</strong> The expanded architecture you are building toward (professional, modular system)</li>
</ul>

<p>
As you add new modules, this guide will grow with your project.
</p>
