<p align="center">
  <a href="./00-OVERVIEW.md">Overview</a> â€¢
  <a href="./04-IMPLEMENTATION.md">Implementation</a> â€¢
  <a href="./05-CHALLENGES.md">Challenges</a>
</p>


<hr />

<h1>ğŸ§© Implementation Guide</h1>

<p>
This guide explains how the Network Traffic Analyzer works internally.  
It covers <strong>A)</strong> the current implementation you have today, and <strong>B)</strong> the expanded, modular architecture you are building toward.
</p>

<hr />

<h2>ğŸ“˜ A) Current Implementation (Your Actual Codebase)</h2>

<p>
Your current analyzer is built around four core modules:
</p>

<pre><code>src/netanal/
â”œâ”€â”€ capture.py      # Packet capture logic
â”œâ”€â”€ parser.py       # Packet parsing and field extraction
â”œâ”€â”€ detectors.py    # Detection logic (e.g., SYN flood)
â”œâ”€â”€ stats.py        # Statistics aggregation
â””â”€â”€ main.py         # Entry point (script-style)
</code></pre>

<h3>1. main.py â€” The Coordinator</h3>

<p>
Your <code>main.py</code> wires the system together. It:
</p>

<ul>
  <li>captures packets</li>
  <li>parses them</li>
  <li>updates statistics</li>
  <li>runs detectors</li>
  <li>prints alerts</li>
</ul>

<p>Current structure:</p>

<pre><code>def handle_packet(pkt):
    parsed = parse_packet(pkt)
    if not parsed:
        return

    update_stats(parsed)

    alert = detect_syn_flood(parsed)
    if alert:
        print("[ALERT]", alert)

capture_packets(handle_packet)
</code></pre>

<p>
This is a simple, functional pipeline. It processes packets as they arrive and performs detection in real time.
</p>

<hr />

<h3>2. capture.py â€” Packet Capture</h3>

<p>
Your capture module uses Scapy to sniff packets and forward them to <code>handle_packet()</code>.  
It is a single-threaded, callback-based design â€” simple and effective for low to moderate traffic.
</p>

<p>
In the future, this will evolve into a producerâ€“consumer engine with a bounded queue.
</p>

<hr />

<h3>3. parser.py â€” Packet Parsing</h3>

<p>
This module extracts:
</p>

<ul>
  <li>source/destination IP</li>
  <li>ports</li>
  <li>protocol</li>
  <li>flags</li>
  <li>packet size</li>
</ul>

<p>
It returns a normalized Python dictionary or object that the rest of the system can use.
</p>

<hr />

<h3>4. detectors.py â€” Detection Logic</h3>

<p>
Your current detector implements a SYN flood heuristic:
</p>

<ul>
  <li>track SYN packets</li>
  <li>detect abnormal rates</li>
  <li>raise alerts</li>
</ul>

<p>
This is the foundation for future IDS-style detection modules.
</p>

<hr />

<h3>5. stats.py â€” Statistics Aggregation</h3>

<p>
This module maintains counters such as:
</p>

<ul>
  <li>total packets</li>
  <li>protocol counts</li>
  <li>source/destination activity</li>
</ul>

<p>
In the expanded architecture, this becomes a thread-safe <code>StatisticsCollector</code>.
</p>

<hr />

<h2>ğŸš€ Summary of Current Implementation</h2>

<p>
Your current analyzer is a clean, minimal pipeline:
</p>

<pre><code>capture â†’ parse â†’ update stats â†’ detect â†’ alert
</code></pre>

<p>
This is the perfect foundation for the expanded architecture.
</p>

<hr />

<h1>ğŸ—ï¸ B) Expanded Architecture (Professional, Modular System)</h1>

<p>
This section describes the <strong>full architecture</strong> your project is evolving toward â€” the one reflected in your README and documentation.
</p>

<p>
These modules do not all exist yet, but this guide explains how they fit together and how your current code will grow into them.
</p>

<pre><code>src/netanal/
â”œâ”€â”€ main.py           # Typer CLI
â”œâ”€â”€ capture.py        # Producer-consumer capture engine
â”œâ”€â”€ analyzer.py       # Protocol identification
â”œâ”€â”€ filters.py        # BPF filter builder
â”œâ”€â”€ statistics.py     # Thread-safe stats collector
â”œâ”€â”€ models.py         # PacketInfo, Protocol, Stats dataclasses
â”œâ”€â”€ visualization.py  # Matplotlib charts
â”œâ”€â”€ export.py         # JSON/CSV export
â”œâ”€â”€ output.py         # Rich console formatting
â”œâ”€â”€ constants.py      # Config values
â””â”€â”€ exceptions.py     # Custom errors
</code></pre>

<hr />

<h2>1. Capture Engine (Future Version)</h2>

<p>
The expanded <code>CaptureEngine</code> uses:
</p>

<ul>
  <li>a producer thread (Scapy AsyncSniffer)</li>
  <li>a consumer thread (processing loop)</li>
  <li>a bounded queue to prevent memory blowup</li>
  <li>thread-safe counters</li>
</ul>

<p>
This design allows high-speed packet capture without dropping packets.
</p>

<hr />

<h2>2. analyzer.py â€” Protocol Identification</h2>

<p>
This module classifies packets into:
</p>

<ul>
  <li>TCP</li>
  <li>UDP</li>
  <li>ICMP</li>
  <li>DNS</li>
  <li>HTTP/HTTPS</li>
  <li>OTHER</li>
</ul>

<p>
It uses Scapy layers and port-based heuristics.
</p>

<hr />

<h2>3. filters.py â€” BPF Filter Builder</h2>

<p>
This module constructs safe, validated BPF expressions:
</p>

<pre><code>FilterBuilder().protocol(Protocol.HTTP).port(80).build()
</code></pre>

<p>
This offloads filtering to the kernel for massive performance gains.
</p>

<hr />

<h2>4. statistics.py â€” Thread-Safe Stats Collector</h2>

<p>
The expanded collector tracks:
</p>

<ul>
  <li>protocol distribution</li>
  <li>endpoint activity</li>
  <li>conversations</li>
  <li>bandwidth samples</li>
</ul>

<p>
All updates occur under a single lock to prevent race conditions.
</p>

<hr />

<h2>5. models.py â€” Data Structures</h2>

<p>
Defines:
</p>

<ul>
  <li><code>PacketInfo</code></li>
  <li><code>Protocol</code> enum</li>
  <li><code>CaptureStatistics</code></li>
</ul>

<p>
This gives your analyzer a clean, typed internal representation.
</p>

<hr />

<h2>6. visualization.py â€” Charts</h2>

<p>
Generates:
</p>

<ul>
  <li>protocol distribution pie charts</li>
  <li>bandwidth graphs</li>
  <li>top talker bar charts</li>
</ul>

<hr />

<h2>7. export.py â€” JSON/CSV Export</h2>

<p>
Allows saving capture results for offline analysis.
</p>

<hr />

<h2>8. output.py â€” Rich Console Formatting</h2>

<p>
Provides:
</p>

<ul>
  <li>tables</li>
  <li>summaries</li>
  <li>color-coded output</li>
</ul>

<hr />

<h2>9. constants.py â€” Configuration</h2>

<p>
Stores:
</p>

<ul>
  <li>queue size</li>
  <li>bandwidth interval</li>
  <li>color mappings</li>
</ul>

<hr />

<h2>10. exceptions.py â€” Custom Errors</h2>

<p>
Defines structured exceptions for:
</p>

<ul>
  <li>permissions</li>
  <li>invalid filters</li>
  <li>capture failures</li>
</ul>

<hr />

<h1>ğŸ¯ Final Notes</h1>

<p>
This Implementation Guide now covers:
</p>

<ul>
  <li><strong>A)</strong> Your current implementation (simple, functional pipeline)</li>
  <li><strong>B)</strong> The expanded architecture you are building toward (professional, modular system)</li>
</ul>

<p>
As you add new modules, this guide will grow with your project.
</p>
