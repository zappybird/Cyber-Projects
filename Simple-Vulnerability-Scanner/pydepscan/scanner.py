"""
scanner.py — Orchestrates the full scan pipeline.

This module is the entry point for a programmatic scan. It:
  1. Accepts one or more dependency file paths
  2. Dispatches each file to the appropriate parser
  3. Sends parsed dependencies to the OSV client for vulnerability lookups
  4. Optionally fetches latest versions from PyPI
  5. Returns a structured report

Nothing in here does I/O directly against external APIs — it delegates
to the client modules so each concern stays testable in isolation.
"""

from __future__ import annotations

from pathlib import Path
from typing import Optional

# These imports will resolve once we flesh out the other modules.
# from pydepscan.osv_client import fetch_vulnerabilities
# from pydepscan.pypi_client import fetch_latest_version
# from pydepscan.parsers.requirements_parser import parse_requirements
# from pydepscan.parsers.pyproject_parser import parse_pyproject


def scan(
    file_paths: list[Path],
    *,
    include_prereleases: bool = False,
    config: Optional[dict] = None,
) -> dict:
    """
    Run a full vulnerability scan over one or more dependency files.

    Args:
        file_paths:          Paths to requirements.txt or pyproject.toml files.
        include_prereleases: If True, pre-release versions are considered when
                             reporting latest available versions from PyPI.
        config:              Optional config dict loaded from .pydepscan.toml
                             or [tool.pydepscan] in pyproject.toml.

    Returns:
        A dict with the shape:
        {
            "dependencies": [...],   # All parsed dependencies
            "vulnerabilities": [...],# Findings from OSV.dev
            "updates_available": [...], # Packages with newer PyPI versions
        }

    Note:
        Parallelism (concurrent HTTP requests) will be introduced here
        once the client modules are complete.
    """
    # TODO: Step 1 — detect file type and dispatch to the right parser
    # TODO: Step 2 — collect all Dependency objects into a flat list
    # TODO: Step 3 — batch-query OSV for vulnerabilities
    # TODO: Step 4 — query PyPI for latest versions (parallel)
    # TODO: Step 5 — assemble and return the report dict
    raise NotImplementedError("scan() will be implemented in a future step.")


def _detect_file_type(path: Path) -> str:
    """
    Determine whether a file is a requirements.txt or pyproject.toml.

    Args:
        path: The file path to inspect.

    Returns:
        One of: "requirements", "pyproject"

    Raises:
        ValueError: If the file type is not recognised.
    """
    # TODO: Use path.name / path.suffix to decide.
    # Edge case: a requirements file might not be named requirements.txt
    # (e.g. requirements-dev.txt), so we match by suffix + heuristics.
    raise NotImplementedError