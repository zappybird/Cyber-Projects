"""
requirements_parser.py — Parser for pip requirements.txt files.

requirements.txt is a line-oriented format where each line is one of:
  - A blank line or comment (starts with #) → skip
  - An option line (starts with -) → e.g. -r other.txt, --index-url ...
  - A PEP 508 dependency specifier → what we care about

PEP 508 specifiers look like:
    requests>=2.28.0          # simple version pin
    requests[security]>=2.28  # with extras
    flask>=1.0,<3.0           # version range
    git+https://...           # VCS URL — we skip these for now

We preserve raw lines and inline comments so that a future updater
module can rewrite version pins without destroying formatting.

Reference: https://pip.pypa.io/en/stable/reference/requirements-file-format/
"""

from __future__ import annotations

from pathlib import Path

from pydepscan.parsers import Dependency


def parse_requirements(file_path: Path) -> list[Dependency]:
    """
    Parse a requirements.txt file into a list of Dependency objects.

    Args:
        file_path: Path to the requirements.txt file to parse.

    Returns:
        A list of Dependency objects, one per valid package line.
        Option lines (-r, --index-url, etc.) are silently skipped.
        VCS and URL requirements are also skipped (logged in a later step).

    Raises:
        FileNotFoundError: If file_path does not exist.
    """
    # TODO: Open file, iterate lines with enumerate() to track line numbers.
    # TODO: Strip whitespace; skip blank lines and comment-only lines.
    # TODO: Call _split_inline_comment() to separate code from comment.
    # TODO: Skip lines starting with '-' (options) or known URL schemes.
    # TODO: Call _parse_specifier_line() on remaining lines.
    # TODO: Attach source_file, line_number, raw_line, comment to each Dependency.
    raise NotImplementedError


def _parse_specifier_line(line: str) -> Dependency:
    """
    Parse a single PEP 508 dependency line into a Dependency object.

    Handles:
      - Plain names:            "flask"
      - With version specifier: "flask>=2.0"
      - With extras:            "requests[security]>=2.28"
      - With multiple specs:    "django>=3.2,<5.0"

    Args:
        line: A single requirements line with no inline comment and
              no leading/trailing whitespace.

    Returns:
        A Dependency with name, specifier, and extras populated.

    Note:
        We intentionally do NOT import packaging here yet. PEP 508 parsing
        will be handled by a future version_utils.py module so we can keep
        this module dependency-free. For now, a regex-based approach is fine.
    """
    # TODO: Use regex to split name, extras [...], and specifier.
    # Regex sketch: r'^([A-Za-z0-9_.-]+)(\[.*?\])?(.*)?$'
    # TODO: Strip and normalise the name (lowercase, replace _ and . with -).
    # TODO: Parse extras from the bracketed group if present.
    # TODO: Return Dependency(name=..., specifier=..., extras=[...]).
    raise NotImplementedError


def _split_inline_comment(line: str) -> tuple[str, str]:
    """
    Split a requirements line into its code part and any inline comment.

    Args:
        line: A raw requirements line, e.g. "flask>=2.0  # our web framework"

    Returns:
        A tuple (code, comment) where comment includes the leading '#',
        or (line, "") if there is no inline comment.

    Note:
        A '#' inside a URL (e.g. a VCS fragment) should not be treated as
        a comment. We handle this by only splitting on ' #' (space-hash).
    """
    # TODO: Split on ' #' to avoid treating URL fragments as comments.
    # TODO: Return (stripped_code, "#" + comment_text) or (line, "").
    raise NotImplementedError