"""
osv_client.py — Client for the OSV.dev vulnerability database API.

OSV (Open Source Vulnerabilities) provides a free, open REST API:
    POST https://api.osv.dev/v1/query      — single package query
    POST https://api.osv.dev/v1/querybatch — batch query (preferred)

We use the batch endpoint to minimise round-trips: instead of one HTTP
request per package, we send all packages in a single request body.

ETag-based caching will be layered on top in a later step, so that
repeated scans of unchanged dependencies skip unnecessary network calls.

Reference: https://google.github.io/osv.dev/api/
"""

from __future__ import annotations

import json
import urllib.request
from dataclasses import dataclass, field
from typing import Any, Optional

OSV_BATCH_URL = "https://api.osv.dev/v1/querybatch"


@dataclass
class Vulnerability:
    """
    A single vulnerability record returned by OSV.

    Attributes:
        osv_id:    The OSV identifier (e.g. "PYSEC-2023-42").
        aliases:   Other IDs like CVE numbers (e.g. ["CVE-2023-12345"]).
        summary:   Short human-readable description.
        severity:  CVSS severity string if available (e.g. "HIGH").
        fixed_in:  The first version that contains a fix, if known.
    """
    osv_id: str
    aliases: list[str] = field(default_factory=list)
    summary: str = ""
    severity: Optional[str] = None
    fixed_in: Optional[str] = None


def fetch_vulnerabilities(
    packages: list[dict[str, str]],
) -> dict[str, list[Vulnerability]]:
    """
    Query OSV.dev for vulnerabilities affecting the given packages.

    Args:
        packages: A list of dicts, each describing one package:
                  [{"name": "requests", "version": "2.28.0"}, ...]
                  The "version" key is optional; omitting it returns all
                  known vulnerabilities for that package across all versions.

    Returns:
        A dict mapping package name → list of Vulnerability objects.
        Packages with no known vulnerabilities map to an empty list.

    Example:
        >>> results = fetch_vulnerabilities([{"name": "flask", "version": "1.0.0"}])
        >>> results["flask"]
        [Vulnerability(osv_id='PYSEC-...', ...)]
    """
    # TODO: Build the OSV batch request body from `packages`.
    # TODO: POST to OSV_BATCH_URL using urllib.request (no external deps).
    # TODO: Parse the JSON response into Vulnerability dataclass instances.
    # TODO: Return the dict keyed by package name.
    # NOTE: Error handling (timeouts, HTTP errors) will be added here too.
    raise NotImplementedError


def _build_batch_request(packages: list[dict[str, str]]) -> dict[str, Any]:
    """
    Build the JSON body for an OSV /v1/querybatch request.

    The OSV batch schema looks like:
        {
          "queries": [
            {"package": {"name": "requests", "ecosystem": "PyPI"}, "version": "2.28.0"},
            ...
          ]
        }

    Args:
        packages: Same format as fetch_vulnerabilities() receives.

    Returns:
        A dict ready to be serialised to JSON and sent as the request body.
    """
    # TODO: Map each package dict to an OSV query object.
    # Always set "ecosystem": "PyPI" since this scanner is Python-specific.
    raise NotImplementedError


def _parse_osv_response(
    response_data: dict[str, Any],
    package_names: list[str],
) -> dict[str, list[Vulnerability]]:
    """
    Convert a raw OSV batch response into a name → Vulnerability mapping.

    OSV returns results in the same order as the queries were sent, so we
    zip the response list with our original package_names list.

    Args:
        response_data: Parsed JSON from the OSV API.
        package_names: Names in the same order they were queried.

    Returns:
        Dict mapping each name to its list of Vulnerability objects.
    """
    # TODO: Iterate response_data["results"], zip with package_names.
    # TODO: Each result may have a "vulns" key (or be empty).
    # TODO: Extract osv_id, aliases, summary, severity, affected versions.
    raise NotImplementedError